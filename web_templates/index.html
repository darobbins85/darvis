<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Darvis - Voice Assistant</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      background: rgba(15, 15, 35, 0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(42, 42, 78, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.5rem;
      font-weight: bold;
      background: linear-gradient(45deg, #00d4ff, #007aff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-left: 1rem;
    }

    .logo img {
      height: 40px;
      width: auto;
      transition: all 0.3s ease;
    }

    /* Listening controls below input */
    .listening-controls {
      display: flex;
      justify-content: center;
      margin-top: 0.5rem;
    }

    .listening-toggle {
      background: rgba(0, 122, 255, 0.1);
      border: 1px solid rgba(0, 122, 255, 0.3);
      color: #00d4ff;
      padding: 0.5rem;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .listening-toggle.active {
      background: rgba(255, 0, 0, 0.4);
      border-color: #ff0000;
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
      animation: listeningPulse 2s infinite;
    }

    @keyframes listeningPulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    .listening-toggle:hover {
      background: rgba(0, 122, 255, 0.15);
    }

    .chat-container {
      position: relative;
      display: flex;
      flex-direction: column;
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      padding: 1rem;
      /* No margin-bottom needed - input is now inside */
      /* Dynamic height that fills available space */
      min-height: calc(100vh - 200px);
      /* Minimum space accounting for header + input + margins */
      box-sizing: border-box;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      scroll-behavior: smooth;
      /* Dynamic height within container */
      min-height: 200px;
      /* Minimum usable height */
      /* Add subtle border */
      border: 1px solid rgba(42, 42, 78, 0.3);
      border-radius: 8px;
      background: rgba(26, 26, 46, 0.3);
      /* Ensure space at bottom when scrolled */
      padding-bottom: 20px;
    }

    .message {
      margin-bottom: 1rem;
      animation: slideIn 0.3s ease-out;
    }

    .message.user {
      display: flex;
      justify-content: flex-end;
    }

    .message.ai {
      display: flex;
      justify-content: flex-start;
    }

    .message.system {
      display: flex;
      justify-content: center;
    }

    .message-bubble {
      max-width: 65%;
      padding: 0.75rem 1rem;
      margin: 20px;
      border-radius: 18px;
      position: relative;
      word-wrap: break-word;
      line-height: 1.4;
      font-size: 0.9rem;
    }

    .message.user .message-bubble {
      background: #007AFF;
      color: white;
      border-bottom-right-radius: 6px;
      margin-left: 3rem;
    }

    .message.ai .message-bubble {
      background: #E5E5EA;
      color: #1C1C1E;
      border-bottom-left-radius: 6px;
      margin-right: 3rem;
    }

    .message.system .message-bubble {
      background: rgba(242, 242, 247, 0.9);
      color: #3C3C43;
      border-radius: 12px;
      font-size: 0.9rem;
      padding: 0.5rem 0.75rem;
      margin: 20px;
      max-width: 60%;
      text-align: center;
    }

    .input-container {
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(42, 42, 78, 0.5);
      border-radius: 12px;
      padding: 1rem;
      margin-top: 1rem;
      /* Centered at bottom of chat container */
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }

    .input-form {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin: 0 auto;
      box-sizing: border-box;
      padding-left: 80px;
    }

    .input-form+.controls {
      max-width: 600px;
      margin: 0.5rem auto 0;
      padding-left: 60px;
    }

    .message-input {
      flex: 1;
      padding: 0.75rem 1rem;
      border: 1px solid rgba(42, 42, 78, 0.5);
      border-radius: 22px;
      background: rgba(26, 26, 46, 0.8);
      color: #e0e0e0;
      font-size: 1rem;
      outline: none;
      transition: all 0.3s ease;
    }

    .message-input:focus {
      border-color: #007AFF;
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
    }

    .send-button {
      background: #007AFF;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 22px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .send-button:hover {
      background: #0056CC;
      transform: translateY(-1px);
    }

    .status-message {
      text-align: center;
      padding: 0.5rem;
      margin-bottom: 1rem;
      border-radius: 8px;
      font-size: 0.9rem;
      animation: fadeIn 0.3s ease-out;
    }

    .status-message.success {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 1px solid rgba(0, 255, 136, 0.3);
    }

    .status-message.error {
      background: rgba(255, 68, 68, 0.1);
      color: #ff4444;
      border: 1px solid rgba(255, 68, 68, 0.3);
    }

    .status-message.info {
      background: rgba(0, 212, 255, 0.1);
      color: #00d4ff;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* Darvis logo with dynamic eyes */
    .darvis-logo-wrapper {
      display: flex;
      justify-content: center;
    }

    .darvis-logo {
      position: relative;
      display: inline-block;
      width: 75px;
      height: 75px;
    }

    .darvis-logo img {
      position: relative;
      z-index: 1;
      height: 75px;
      width: 75px;
      display: block;
    }

    /* Logo inside input container, left side */
    .darvis-logo-wrapper-bottom {
      position: absolute;
      left: 10px;
      bottom: 50%;
      transform: translateY(50%);
    }

    .darvis-logo-wrapper-bottom .eye-glow {
      height: 5px;
      width: 5px;
    }

    .darvis-logo-wrapper-bottom .eye-glow.left {
      top: 14px;
      left: 20px;
    }

    .darvis-logo-wrapper-bottom .eye-glow.right {
      top: 14px;
      left: 26px;
    }

    /* AI Processing Indicator */
    .cancel-button {
      background: none;
      border: none;
      color: #ff4444;
      cursor: pointer;
      font-size: 14px;
      margin-left: 10px;
      padding: 2px 6px;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .cancel-button:hover {
      background: rgba(255, 68, 68, 0.2);
      transform: scale(1.1);
    }

    #ai-dots {
      animation: blink 1.5s infinite;
    }

    @keyframes blink {

      0%,
      50% {
        opacity: 1;
      }

      51%,
      100% {
        opacity: 0.3;
      }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(15, 15, 35, 0.5);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(42, 42, 78, 0.5);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 212, 255, 0.5);
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .chat-container {
        margin-bottom: 10px;
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
      }

      .header {}

      .input-container {
        padding: 1rem;
        margin-top: 50px;
      }

      .message-bubble {
        max-width: 80%;
        font-size: 0.85rem;
      }

      .message.user .message-bubble {
        margin-left: 2rem;
      }

      .message.ai .message-bubble {
        margin-right: 2rem;
      }

      .code-block {
        max-width: 100%;
        font-size: 0.75rem;
      }
    }

    /* Code block styling */
    .code-block {
      background: #1e1e2e;
      border-radius: 8px;
      margin: 0.75rem 0;
      overflow: hidden;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .code-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #2a2a3e;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #3a3a5e;
    }

    .code-block-language {
      color: #00d4ff;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .code-block-copy {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
      color: #00d4ff;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.7rem;
      transition: all 0.2s ease;
    }

    .code-block-copy:hover {
      background: rgba(0, 212, 255, 0.2);
    }

    .code-block-copy.copied {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.5);
      color: #00ff88;
    }

    .code-block pre {
      margin: 0;
      padding: 0.75rem;
      overflow-x: auto;
      white-space: pre;
    }

    .code-block code {
      font-family: inherit;
      color: #e0e0e0;
    }

    /* JSON syntax highlighting - lighter colors for dark background */
    .json-key {
      color: #ff79c6;
    }

    .json-string {
      color: #a6e3a1;
    }

    .json-number {
      color: #89b4fa;
    }

    .json-boolean {
      color: #f38ba8;
    }

    .json-null {
      color: #bac2de;
    }

    .json-bracket {
      color: #cdd6f4;
    }
  </style>


</head>

<body>

  <div class="chat-container">

    <div id="status-messages"></div>
    <div id="chat-messages" class="chat-messages">
      <div class="message system">
        <div class="message-bubble">
          üëã Welcome to Darvis! I'm your AI voice assistant. Type a message or enable listening mode to get started.
        </div>
      </div>
      <!-- AI Processing Indicator -->
      <div id="ai-processing-indicator" class="message ai" style="display: none;">
        <div class="message-bubble">
          <span id="ai-dots">...</span>
          <span id="ai-timer">(0s)</span>
          <button id="cancel-ai" class="cancel-button" title="Cancel AI request">‚ùå</button>
        </div>
      </div>
    </div>

    <!-- Input container centered at bottom of chat -->
    <div class="input-container">

      <!-- Darvis logo at bottom left -->
      <div class="darvis-logo-wrapper-bottom">
        <div class="darvis-logo">
          <img id="darvis-logo-img" src="/static/darvis-logo.png">
        </div>
      </div>

      <div>
        <form id="message-form" class="input-form">
          <input type="text" id="message-input" class="message-input" placeholder="Type your message..."
            autocomplete="off">
          <button type="submit" class="send-button">
            Send ‚úâÔ∏è
          </button>
          <button id="listening-toggle" class="listening-toggle">
            üé§
          </button>
        </form>
      </div>

      <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
      <script>
        const socket = io();
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const messageForm = document.getElementById('message-form');
        const statusMessages = document.getElementById('status-messages');
        const listeningToggle = document.getElementById('listening-toggle');

        let listeningEnabled = false;
        let currentEyeState = 'idle'; // idle, wake, ai
        let recognition = null;
        let recognitionActive = false;
        let waitingForCommand = false;
        let commandTimeout = null;
        let aiProcessing = false;
        let aiStartTime = null;
        let aiTimerInterval = null;
        let restartPending = false;

        // Eye control functions
        function setEyeState(state) {
          console.log('üëÅÔ∏è setEyeState called with:', state);
          const logoImg = document.getElementById('darvis-logo-img');
          const timestamp = Date.now();

          // Change the logo image based on state
          if (state === 'wake') {
            console.log('üëÅÔ∏è Setting logo to green eyes');
            logoImg.src = '/static/darvis-logo-hires-green-eyes.png?v=' + timestamp;
          } else if (state === 'ai') {
            console.log('üëÅÔ∏è Setting logo to red eyes');
            logoImg.src = '/static/darvis-logo-hires-red-eyes.png?v=' + timestamp;
          } else {
            console.log('üëÅÔ∏è Setting logo to base');
            logoImg.src = '/static/darvis-logo.png?v=' + timestamp;
          }

          currentEyeState = state;
        }

        // AI Processing functions
        function startAiProcessing() {
          console.log('ü§ñ Starting AI processing...');
          aiProcessing = true;
          aiStartTime = Date.now();
          setEyeState('ai');

          // Show processing indicator
          const indicator = document.getElementById('ai-processing-indicator');
          indicator.style.display = 'block';

          // Start timer
          aiTimerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - aiStartTime) / 1000);
            document.getElementById('ai-timer').textContent = `(${elapsed}s)`;
          }, 1000);

          // Scroll to show the indicator
          indicator.scrollIntoView({behavior: 'smooth'});
        }

        function stopAiProcessing() {
          console.log('ü§ñ Stopping AI processing...');
          aiProcessing = false;
          clearInterval(aiTimerInterval);
          setEyeState('idle');

          // Hide processing indicator
          document.getElementById('ai-processing-indicator').style.display = 'none';
        }

        // Cancel AI processing
        document.addEventListener('DOMContentLoaded', () => {
          document.getElementById('cancel-ai').addEventListener('click', () => {
            console.log('‚ùå User cancelled AI request');
            stopAiProcessing();
            socket.emit('cancel_ai_request');
            showStatus('AI request cancelled', 'warning');
          });
        });

        // Initialize speech recognition
        function initSpeechRecognition() {
          if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            // Try to improve recognition
            if (recognition.hasOwnProperty('maxAlternatives')) {
              recognition.maxAlternatives = 1;
            }

            recognition.onstart = function () {
              console.log('üé§ Speech recognition started');
              recognitionActive = true;
              showStatus('Listening... say "hey darvis"', 'info');
            };

            recognition.onresult = function (event) {
              const text = event.results[0][0].transcript;
              console.log('üé§ Browser heard:', text);
              socket.emit('speech_recognized', {text: text});
            };

            recognition.onerror = function (event) {
              console.error('üé§ Speech recognition error:', event.error);

              // Handle different error types
              if (event.error === 'no-speech') {
                console.log('üé§ No speech detected, restarting...');
                // Don't show "no-speech" errors to user, just restart
                if (listeningEnabled && !waitingForCommand && !restartPending) {
                  setTimeout(() => startListening(), 1500); // Wait longer before restart
                }
              } else if (event.error === 'not-allowed') {
                showStatus('Microphone access denied. Please allow microphone access and try again.', 'error');
                listeningEnabled = false;
                listeningToggle.classList.remove('active');
              } else if (event.error === 'network') {
                showStatus('Speech recognition network error', 'error');
              } else {
                showStatus('Speech recognition error: ' + event.error, 'error');
              }
            };

            recognition.onend = function () {
              console.log('üé§ Speech recognition ended');
              recognitionActive = false;
              // Restart listening if still enabled and not waiting for command
              if (listeningEnabled && !waitingForCommand && !restartPending) {
                setTimeout(() => startListening(), 1000);
              }
            };

            console.log('üé§ Speech recognition initialized');
          } else {
            console.error('üé§ Speech recognition not supported in this browser');
            showStatus('Speech recognition not supported in this browser. Try Chrome or Firefox.', 'error');
          }
        }

        function startListening() {
          if (recognition && listeningEnabled && !restartPending) {
            console.log('üé§ Starting browser speech recognition...');
            restartPending = true;
            try {
              recognition.start();
              restartPending = false;
            } catch (error) {
              console.error('üé§ Failed to start speech recognition:', error);
              restartPending = false;
              if (error.name === 'InvalidStateError') {
                console.log('üé§ Recognition already started, will retry later...');
                // Don't retry immediately to avoid spam
                setTimeout(() => {
                  if (listeningEnabled && !waitingForCommand) {
                    startListening();
                  }
                }, 2000);
              }
            }
          }
        }

        function stopListening() {
          if (recognition && recognitionActive) {
            console.log('üé§ Stopping browser speech recognition...');
            recognitionActive = false;
            try {
              recognition.stop();
            } catch (error) {
              console.error('üé§ Error stopping recognition:', error);
            }
          }
        }

        // Handle form submission
        messageForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const message = messageInput.value.trim();
          if (message) {
            // If we were waiting for a command, stop waiting
            if (waitingForCommand) {
              clearTimeout(commandTimeout);
              waitingForCommand = false;
              console.log('üìù Manual message sent, stopping command wait');
            }
            socket.emit('chat_message', {message: message});
            messageInput.value = '';
            startAiProcessing();
          }
        });

        // Handle listening toggle
        listeningToggle.addEventListener('click', () => {
          listeningEnabled = !listeningEnabled;

          if (listeningEnabled) {
            listeningToggle.classList.add('active');
            setEyeState('wake'); // Green eyes when listening
            console.log('üé§ Listening mode enabled - using browser microphone');

            // Test microphone access
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              navigator.mediaDevices.getUserMedia({audio: true})
                .then(function (stream) {
                  console.log('üé§ Microphone access granted');
                  stream.getTracks().forEach(track => track.stop()); // Stop the test stream
                  startListening();
                })
                .catch(function (error) {
                  console.error('üé§ Microphone access denied:', error);
                  showStatus('Microphone access required for voice commands', 'error');
                  listeningEnabled = false;
                  listeningToggle.classList.remove('active');
                });
            } else {
              // Fallback for older browsers
              startListening();
            }
          } else {
            listeningToggle.classList.remove('active');
            console.log('üé§ Listening mode disabled');
            stopListening();
            console.log('üé§ Setting eye state to idle');
            setEyeState('idle'); // Return to idle when listening disabled
            // Clear any pending command timeout
            if (commandTimeout) {
              clearTimeout(commandTimeout);
              commandTimeout = null;
            }
            waitingForCommand = false;
          }
        });

        // Handle incoming user messages
        socket.on('user_message', (data) => {
          addMessage(data.message, 'user');
        });

        // Handle incoming AI messages
        socket.on('ai_message', (data) => {
          stopAiProcessing();
          // If listening mode is still enabled, restart speech recognition for next command
          if (listeningEnabled) {
            console.log('üîÑ Restarting speech recognition after AI response...');
            setEyeState('wake'); // Green eyes while waiting for next command
            setTimeout(() => {
              if (listeningEnabled) {
                startListening();
              }
            }, 1000);
          }
          addMessage(data.message, 'ai');
        });

        // Handle wake word detection
        socket.on('wake_word', (data) => {
          console.log('üéâ Wake word detected! Eyes turning green...');
          setEyeState('wake'); // Green eyes for wake word
        });

        // Handle AI cancellation
        socket.on('ai_cancelled', (data) => {
          console.log('‚ùå AI request cancelled');
          stopAiProcessing();
          // If listening mode is still enabled, restart speech recognition
          if (listeningEnabled) {
            console.log('üîÑ Restarting speech recognition after AI cancellation...');
            setEyeState('wake'); // Green eyes while waiting for next command
            setTimeout(() => {
              if (listeningEnabled) {
                startListening();
              }
            }, 1000);
          }
        });

        // Handle speech recognized from browser
        socket.on('speech_recognized_response', (data) => {
          const text = data.text;
          console.log('üìù Processing recognized speech:', text);

          // If listening mode is enabled, process any speech as a command
          if (listeningEnabled) {
            console.log('üìù Voice command received:', text);
            // Stop speech recognition while AI processes
            if (recognition) {
              try {
                recognition.stop();
              } catch (e) {
                // Ignore if already stopped
              }
            }
            socket.emit('chat_message', {message: text});
            // Show AI processing indicator
            startAiProcessing();
          } else {
            console.log('‚ùå Speech detected but listening not enabled, ignoring');
          }
        });

        // Add message to chat
        function addMessage(message, type) {
          const messageDiv = document.createElement('div');
          messageDiv.className = `message ${type}`;

          let bubbleClass = 'message-bubble';
          let content = message;

          if (type === 'voice') {
            bubbleClass += ' voice-input';
            content = `üé§ ${message}`;
            messageDiv.className = 'message user';
          }

          // Parse and render code blocks for AI messages
          if (type === 'ai') {
            content = renderMessageWithCodeBlocks(message);
          }

          messageDiv.innerHTML = `
                <div class="${bubbleClass}">
                    ${content}
                </div>
            `;

          // Insert before the AI processing indicator
          const processingIndicator = document.getElementById('ai-processing-indicator');
          chatMessages.insertBefore(messageDiv, processingIndicator);

          // Auto-scroll to show the new message at the bottom
          setTimeout(() => {
            try {
              messageDiv.scrollIntoView({behavior: 'smooth', block: 'end'});
            } catch (e) {
              messageDiv.scrollIntoView(false);
            }
          }, 100);
        }

        // Parse message text and render code blocks
        function renderMessageWithCodeBlocks(text) {
          // Match ```language ... ``` code blocks - handles various AI output formats
          // First try with language specifier: ```json ... ``` or ```json\n...\n```
          let result = text;

          // Pattern 1: ```language ... ``` (language directly after backticks, possibly with space)
          const pattern1 = /```(\w+)\s*([\s\S]*?)```/g;
          result = result.replace(pattern1, (match, language, code) => {
            const trimmedCode = code.trim();
            if (!trimmedCode) return '';
            const escapedCode = escapeHtml(trimmedCode);
            const highlightedCode = highlightJson(escapedCode);
            return `
          <div class="code-block">
            <div class="code-block-header">
              <span class="code-block-language">${language}</span>
              <button class="code-block-copy" onclick="copyCode(this, \`${escapeForAttribute(trimmedCode)}\`)">Copy</button>
            </div>
            <pre><code>${highlightedCode}</code></pre>
          </div>
        `;
          });

          // Pattern 2: ```\n...\n``` (just code block markers, no language)
          const pattern2 = /```\n?([\s\S]*?)```/g;
          result = result.replace(pattern2, (match, code) => {
            const trimmedCode = code.trim();
            if (!trimmedCode) return '';
            const escapedCode = escapeHtml(trimmedCode);
            const highlightedCode = highlightJson(escapedCode);
            return `
          <div class="code-block">
            <div class="code-block-header">
              <span class="code-block-language">code</span>
              <button class="code-block-copy" onclick="copyCode(this, \`${escapeForAttribute(trimmedCode)}\`)">Copy</button>
            </div>
            <pre><code>${highlightedCode}</code></pre>
          </div>
        `;
          });

          // Convert **bold** to HTML
          result = result.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

          // Convert newlines to <br> outside code blocks
          // Split by code blocks and convert newlines in text portions
          const parts = result.split(/(<div class="code-block">[\s\S]*?<\/div>)/g);
          result = parts.map(part => {
            if (part.startsWith('<div class="code-block">')) {
              return part;
            }
            return part.replace(/\n/g, '<br>');
          }).join('');

          return result;
        }

        // Escape HTML special characters
        function escapeHtml(text) {
          const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
          };
          return text.replace(/[&<>"']/g, m => map[m]);
        }

        // Escape text for use in onclick attribute
        function escapeForAttribute(text) {
          return text.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/`/g, '\\`').replace(/\$/g, '\\$');
        }

        // Simple JSON syntax highlighting
        function highlightJson(code) {
          // Only highlight if it looks like JSON (starts with { or [)
          const trimmed = code.trim();
          if (!trimmed.startsWith('{') && !trimmed.startsWith('[')) {
            return code; // Return as-is if not JSON-like
          }

          // Escape HTML first to prevent XSS and display issues
          let escaped = escapeHtml(code);

          // Apply highlighting patterns in the right order
          let highlighted = escaped
            // Keys (strings followed by colon)
            .replace(/"([^"\\]|\\.)*"\s*:/g, (match) => {
              return '<span class="json-key">' + match + '</span>';
            })
            // String values (colon followed by string)
            .replace(/:\s*("([^"\\]|\\.)*")/g, (match, full, inner) => {
              return ': <span class="json-string">' + full + '</span>';
            })
            // Numbers
            .replace(/:\s*(-?\d+\.?\d*)/g, (match, num) => {
              return ': <span class="json-number">' + num + '</span>';
            })
            // Booleans
            .replace(/:\s*(true|false)/g, (match, bool) => {
              return ': <span class="json-boolean">' + bool + '</span>';
            })
            // Null
            .replace(/:\s*(null)/g, (match, nullVal) => {
              return ': <span class="json-null">' + nullVal + '</span>';
            })
            // Brackets and braces last
            .replace(/([{}\[\]])/g, '<span class="json-bracket">$1</span>');

          return highlighted;
        }

        // Copy code to clipboard
        function copyCode(button, code) {
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = 'Copied!';
            button.classList.add('copied');
            setTimeout(() => {
              button.textContent = 'Copy';
              button.classList.remove('copied');
            }, 2000);
          }).catch(err => {
            console.error('Failed to copy:', err);
            button.textContent = 'Failed';
          });
        }

        // Show status message
        function showStatus(message, type = 'info') {
          const statusDiv = document.createElement('div');
          statusDiv.className = `status-message ${type}`;
          statusDiv.textContent = message;

          statusMessages.appendChild(statusDiv);

          // Auto-remove after 5 seconds
          setTimeout(() => {
            if (statusDiv.parentNode) {
              statusDiv.remove();
            }
          }, 5000);
        }

        // Initialize speech recognition on page load
        initSpeechRecognition();

        // Auto-focus input on page load
        messageInput.focus();

        // Show connection status
        socket.on('connect', () => {
          showStatus('Connected to Darvis', 'success');
        });

        socket.on('disconnect', () => {
          showStatus('Disconnected from Darvis', 'error');
        });
      </script>
</body>

</html>
